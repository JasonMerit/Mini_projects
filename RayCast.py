# https://www.youtube.com/watch?v=gYRrGTC7GtA&list=LL&index=1
import pygame as pg
import os
from OpenGL.GL import *
from OpenGL.GLU import *
from math import cos, sin, tan, pi, tau, pow, sqrt

W, H = 1200, 600
FoV = 90
px, py = 200, 300
pa = 3*pi/2
SPEED = 2
OMEGA = 2
pdx, pdy = cos(pa)*SPEED, sin(pa)*SPEED
SIZE = 64
P2 = pi/2
P3 = 3*pi/2
DEGREE = pi/180
SKY = 0, 0.9, 0.9
FLOOR = 0, 0.6, 0
offset_3D_X = 550
offset_3D_Y = H // 2
FAT = 10  # Distance to collide with a wall
KEK = 385

def deg_to_rad(deg):
    return deg * pi / 180

def fix_ang(a):
    if a > 359: a -= 360
    if a < 0: a += 360
    return a

def dist1(ax, ay, bx, by):
    return sqrt(pow(bx - ax, 2) + pow(by - ay, 2))

def dist(ax, ay, bx, by, angle):
    return cos(deg_to_rad(angle))*(bx-ax)-sin(deg_to_rad(angle))*(by-ay)

All_Textures = [               # all 32x32 textures
 # Checkerboard 
 [
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,1,1,1,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,1,1,1,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,1,1,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],

 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0],

 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1],

 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0], 
 [1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,0]],
 # Brick
 [
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],

 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],

 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1],
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],

 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0]],
 # Window
 [
 [1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1], 
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],    
       
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1], 

 [1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],   
       
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],  
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1], 
 [1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1]],
 # Door
 [
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],  
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],  
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],    
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],    
 [0,0,0,1,1,1,1,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,1,1,1,1,0,0,0],  
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],  
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],   
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],     

 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],  
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],    
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],    
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],   
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],  
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],  
 [0,0,0,1,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,0,0,0,1,0,0,0],  
 [0,0,0,1,1,1,1,1, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 1,1,1,1,1,0,0,0],  

 [0,0,0,0,0,0,0,0, 0,0,0,0,0,1,0,1, 1,0,1,0,0,0,0,0, 0,0,0,0,0,0,0,0],  
 [0,0,0,0,0,0,0,0, 0,0,1,1,1,1,0,1, 1,0,1,1,1,1,0,0, 0,0,0,0,0,0,0,0],   
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],    
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],    
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],  
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],  
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],   
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0], 
 
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],  
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],     
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],   
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],   
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],   
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0],  
 [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1, 1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0],   
 [0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0]]    
]

mapW = [          #walls
 [1,1,1,1,1,3,1,1],
 [1,0,0,1,0,0,0,1],
 [1,0,0,4,0,2,0,1],
 [1,1,4,1,0,0,0,1],
 [2,0,0,0,0,0,0,1],
 [2,0,0,0,0,1,0,1],
 [2,0,0,0,0,0,0,1],
 [1,1,3,1,3,1,3,1]	
]

mapF = [          #floors
 [0,0,0,0,0,0,0,0],
 [0,0,0,0,1,1,0,0],
 [0,0,0,0,2,0,0,0],
 [0,0,0,0,0,0,0,0],
 [0,0,2,0,0,0,0,0],
 [0,0,0,0,0,0,0,0],
 [0,1,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,0]	
]

mapC = [          #ceiling
 [0,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,1,0],
 [0,1,3,1,0,0,0,0],
 [0,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0],
 [0,0,0,0,0,0,0,0]	
]


MAP = [
 [1,1,1,1,1,1,1,1],
 [1,0,1,0,0,0,0,1],
 [1,0,1,0,0,0,0,1],
 [1,0,1,0,0,0,0,1],
 [1,0,0,0,2,0,0,1],
 [1,0,0,0,0,1,0,1],
 [1,0,0,0,0,0,0,1],
 [1,1,1,1,1,1,1,1],	
]

MAP_Y = len(MAP)
MAP_X = len(MAP[0])
MAP_S = MAP_Y * MAP_X


def events():
    for event in pg.event.get():
        if event.type == pg.VIDEORESIZE:
            global W, H
            W, H = event.w, event.h
            pg.display.set_mode((W,H), pg.DOUBLEBUF|pg.OPENGL|pg.RESIZABLE)
        if event.type == pg.QUIT:
            pg.quit()
            quit()
        if event.type == pg.MOUSEBUTTONDOWN:
            print(pg.mouse.get_pos())
        
        # if event.type == pg.KEYDOWN:
            
            

def input():
    keys = pg.key.get_pressed()

    if keys[pg.K_ESCAPE]:
        pg.quit()
        quit()

    global px, py, pdx, pdy, pa
    if keys[pg.K_a]:
        pa += OMEGA
        pa = fix_ang(pa)
        pdx = cos(deg_to_rad(pa))*SPEED
        pdy = -sin(deg_to_rad(pa))*SPEED

    if keys[pg.K_d]:
        pa -= OMEGA
        pa = fix_ang(pa)
        pdx = cos(deg_to_rad(pa))*SPEED
        pdy = -sin(deg_to_rad(pa))*SPEED
    
    if keys[pg.K_w]:
        xo = -FAT if pdx < 0 else FAT
        yo = -FAT if pdy < 0 else FAT

        ipx = int(px //  SIZE); ipx_add_xo = int((px + xo) // SIZE)
        ipy = int(py // SIZE); ipy_add_yo = int((py + yo) // SIZE)

        if not MAP[ipy][ipx_add_xo]: px += pdx
        if not MAP[ipy_add_yo][ipx]: py += pdy

    if keys[pg.K_s]:
        xo = -FAT if pdx < 0 else FAT
        yo = -FAT if pdy < 0 else FAT

        ipx = int(px // SIZE); ipx_sub_xo = int((px - xo) // SIZE)
        ipy = int(py // SIZE); ipy_sub_yo = int((py - yo) // SIZE)

        if not MAP[ipy][ipx_sub_xo]: px -= pdx
        if not MAP[ipy_sub_yo][ipx]: py -= pdy
    
    if keys[pg.K_SPACE]:
        # print window width and height
        w, h = pg.display.get_surface().get_size()
        print(w, h)

    global KEK    
    if keys[pg.K_DOWN]:
        KEK -= 1
        print(KEK)
    if keys[pg.K_UP]:
        KEK += 1
        print(KEK)


def draw_player():
    glPointSize(8)
    glColor3f(0.1, 1, 0)
    glBegin(GL_POINTS)
    glVertex2i(int(px), int(py))
    glEnd()

    glLineWidth(3)  # The nose
    glColor(0.1, 1, 0)
    glBegin(GL_LINES)
    glVertex2i(int(px), int(py))
    glVertex2i(int(px + pdx * 6), int(py + pdy * 6))
    glEnd()

def draw_2d_walls():
    for y in range(len(MAP)):
        for x in range(len(MAP[y])):
            color = (1, 1, 1) if MAP[y][x] else (0, 0, 0)
            xo = x * SIZE
            yo = y * SIZE
            glColor3f(*color)
            glBegin(GL_QUADS)
            glVertex(xo+1, yo+1)
            glVertex(xo+1, yo+SIZE-1)
            glVertex(xo+SIZE-1, yo+SIZE-1)
            glVertex(xo+SIZE-1, yo+1)
            glEnd()


def cast_ray(ra):
    # --- Vertical ---
        dof = 0  # depth of field
        distV = 100000 # distance to vertical wall
        vx, vy = px, py # coordinates of vertical wall
        Tan = tan(deg_to_rad(ra))
        if cos(deg_to_rad(ra)) > 0.001: # looking left
            rx = ((int(px)>>6)<<6) + SIZE 
            ry = (px - rx) * Tan + py
            xo = SIZE
            yo = - xo * Tan
        elif cos(deg_to_rad(ra)) < -0.001: # looking right
            rx = ((int(px)>>6)<<6) - 0.0001
            ry = (px - rx) * Tan + py
            xo = -SIZE
            yo = - xo * Tan
        else:  # looking straight up or down
            rx = px
            ry = py
            dof = 8
        while dof < 8:  # iterate until wall is found
            mx = int(rx)>>6  # map x
            my = int(ry)>>6  # map y
            if 0 <= mx < MAP_X and 0 <= my < MAP_Y and MAP[my][mx]: # if wall is found
                vx = rx
                vy = ry
                distV = dist(px, py, rx, ry, ra)
                valueV = MAP[my][mx]
                dof = 8
            else:  # next line
                rx += xo
                ry += yo
                dof += 1
        
        # --- Horizontal ---
        dof = 0  # depth of field
        distH = 100000 # distance to horizontal wall
        Tan = 1/Tan
        if sin(deg_to_rad(ra)) > 0.001: # looking up
            ry = ((int(py)>>6)<<6) - 0.0001
            rx = (py - ry) * Tan + px
            yo = -SIZE
            xo = - yo * Tan
        elif sin(deg_to_rad(ra)) < -0.001: # looking down
            ry = ((int(py)>>6)<<6) + SIZE
            rx = (py - ry) * Tan + px
            yo = SIZE
            xo = - yo * Tan
        else:  # looking straight left or right
            rx = px
            ry = py
            dof = 8
        while dof < 8:  # iterate until wall is found
            mx = int(rx)>>6  # map x
            my = int(ry)>>6  # map y
            if 0 <= mx < MAP_X and 0 <= my < MAP_Y and MAP[my][mx]:
                distH = dist(px, py, rx, ry, ra)
                valueH = MAP[my][mx]
                dof = 8
            else:  # next line
                rx += xo
                ry += yo
                dof += 1
        
        if distV < distH:
            rx = vx
            ry = vy
            distance = distV
            value = valueV
            if value == 1:
                wall_color = (1, 0, 0)
            elif value == 2:
                wall_color = (0, 0, 1)
        else:
            distance = distH
            value = valueH
            if value == 1:
                wall_color = (0.7, 0, 0)
            elif value == 2:
                wall_color = (0, 0, 0.7)
        
        return rx, ry, distance, wall_color

def draw_rays_and_walls():
    ra = fix_ang(pa + FoV // 2)
        
    for r in range(FoV):
        rx, ry, distance, wall_color = cast_ray(ra)
        
        # draw ray
        glLineWidth(4)
        glColor3f(*wall_color)
        glBegin(GL_LINES)
        glVertex2i(int(px), int(py))
        glVertex2i(int(rx), int(ry))
        glEnd()

        # --- Draw 3d walls ---
        
        # fix fisheye
        ca = pa - ra  
        if ca < 0: ca += tau
        if ca > tau: ca -= tau
        distance *= cos(deg_to_rad(ca))

        k = 320# * 1.2
        lineH = int(MAP_S * k // distance) # height of line
        if lineH > k: lineH = k
        # lineO = int((k >> b-1) - lineH >> 1)  # line offset
        lineO = int(offset_3D_Y - lineH // 2)  # line offset (3/4 of screen)
        t = 7
        m = 142  # not general for different k, but approximates upper and lower bound

        glLineWidth(t)
        
        glBegin(GL_LINES)
        glColor3f(*SKY)
        glVertex2i(r*t+offset_3D_X, m)
        glVertex2i(r*t+offset_3D_X, lineO)
        glColor3f(*wall_color)
        glVertex2i(r*t+offset_3D_X, lineO)
        glVertex2i(r*t+offset_3D_X, lineH + lineO)
        glColor3f(*FLOOR)
        glVertex2i(r*t+offset_3D_X, lineH + lineO)
        glVertex2i(r*t+offset_3D_X, k + m)
        glEnd()

        # glColor3f(*wall_color)
        # glPointSize(t)
        # ty = 0
        # print(All_Textures[0])
        # for y in range(lineH):
        #     c = All_Textures[0][y][r]
        #     glColor3f(c, c, c)
        #     glBegin(GL_POINTS)
        #     glVertex2i(r*t+offset_3D_X, y+lineO)
        #     glEnd()
        
        ra = fix_ang(ra - 1)
        

def display():
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
    glClearColor(0.3,0.3,0.3,0)
    draw_2d_walls()
    draw_rays_and_walls()
    draw_player()
    pg.display.flip()


def main():
    pg.init()
    os.environ['SDL_VIDEO_WINDOW_POS'] = "%d,%d" % (40, 40)
    pg.display.set_mode((W,H), pg.DOUBLEBUF|pg.OPENGL|pg.RESIZABLE)
    pg.display.set_caption("RayCast")
    gluOrtho2D(0, W, H, 0)
    clock = pg.time.Clock()

    while True:
        events()
        input()
        display()
        clock.tick(60)
        

if __name__ == "__main__":
    main()